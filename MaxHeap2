public class MaxHeapComparer : Comparer<Tuple<int, int[]>> {
    public override int Compare(Tuple<int, int[]> tup1, Tuple<int, int[]> tup2) {
        return tup2.Item1 - tup1.Item1;
    }
}

    /// <summary>
    /// Maximum Heap Data Structure.
    /// </summary>
    public class Heap<T>
    {
        /// <summary>
        /// Instance Variables.
        /// _collection: The list of elements. Implemented as an array-based list with auto-resizing.
        /// </summary>
        private List<T> collection { get; set; }
        private Comparer<T> heapComparer = Comparer<T>.Default;
        
        /// <summary>
        /// CONSTRUCTORS
        /// </summary>
        public Heap() : this(0, null) { }
        public Heap(Comparer<T> comparer) : this(0, comparer) { }
        public Heap(int capacity, Comparer<T> comparer)
        {
            collection = new List<T>(capacity);
            heapComparer = comparer ?? Comparer<T>.Default;
        }

        /// <summary>
        /// Private Method. Builds a max heap from the inner array-list _collection.
        /// </summary>
        private void buildMaxHeap()
        {
            int lastIndex = collection.Count - 1;
            int lastNodeWithChildren = (lastIndex / 2);

            for (int node = lastNodeWithChildren; node >= 0; node--)
            {
                maxHeapify(node, lastIndex);
            }
        }

        /// <summary>
        /// Private Method. Used in Building a Max Heap.
        /// </summary>
        private void maxHeapify(int nodeIndex, int lastIndex)
        {
            // assume that the subtrees left(node) and right(node) are max-heaps
            int left = (nodeIndex * 2) + 1;
            int right = left + 1;
            int largest = nodeIndex;

            // If collection[left] > collection[nodeIndex]
            if (left <= lastIndex && heapComparer.Compare(collection[left], collection[nodeIndex]) > 0)
                largest = left;

            // If collection[right] > collection[largest]
            if (right <= lastIndex && heapComparer.Compare(collection[right], collection[largest]) > 0)
                largest = right;

            // Swap and heapify
            if (largest != nodeIndex)
            {
                Swap(collection, nodeIndex, largest);
                maxHeapify(largest, lastIndex);
            }
        }

        /// <summary>
        /// Returns the number of elements in heap
        /// </summary>
        public int Count
        {
            get { return collection.Count; }
        }

        /// <summary>
        /// Checks whether this heap is empty
        /// </summary>
        public bool IsEmpty
        {
            get { return (collection.Count == 0); }
        }

        /// <summary>
        /// Gets or sets the at the specified index.
        /// </summary>
        public T this[int index]
        {
            get
            {
                if (index < 0 || index > this.Count || this.Count == 0)
                {
                    throw new IndexOutOfRangeException();
                }

                return collection[index];
            }
            set
            {
                if (index < 0 || index >= this.Count)
                {
                    throw new IndexOutOfRangeException();
                }

                collection[index] = value;

                if (heapComparer.Compare(collection[index], collection[0]) >= 0) // greater than or equal to max
                {
                    Swap(collection, 0, index);
                    buildMaxHeap();
                }
            }
        }

        /// <summary>
        /// Heapifies the specified newCollection. Overrides the current heap.
        /// </summary>
        public void Initialize(IList<T> newCollection)
        {
            if (newCollection.Count > 0)
            {
                // Reset and reserve the size of the newCollection
                collection = new List<T>(newCollection.Count);

                // Copy the elements from the newCollection to the inner collection
                for (int i = 0; i < newCollection.Count; ++i)
                {
                    collection.Insert(i, newCollection[i]);
                }

                // Build the heap
                buildMaxHeap();
            }
        }

        /// <summary>
        /// Adding a new key to the heap.
        /// </summary>
        public void Add(T heapKey)
        {
            if (IsEmpty)
            {
                collection.Add(heapKey);
            }
            else
            {
                collection.Add(heapKey);
                buildMaxHeap();
            }
        }

        /// <summary>
        /// Find the maximum node of a max heap.
        /// </summary>
        public T Peek()
        {
            if (IsEmpty)
            {
                throw new Exception("Heap is empty.");
            }

            return collection.First();
        }

        /// <summary>
        /// Removes the node of minimum value from a min heap.
        /// </summary>
        public void RemoveMax()
        {
            if (IsEmpty)
            {
                throw new Exception("Heap is empty.");
            }

            int max = 0;
            int last = collection.Count - 1;
            Swap(collection, max, last);

            collection.RemoveAt(last);
            last--;

            maxHeapify(0, last);
        }

        /// <summary>
        /// Returns the node of maximum value from a max heap after removing it from the heap.
        /// </summary>
        public T Extract()
        {
            var max = Peek();
            RemoveMax();
            return max;
        }

        /// <summary>
        /// Clear this heap.
        /// </summary>
        public void Clear()
        {
            if (IsEmpty)
            {
                throw new Exception("Heap is empty.");
            }

            collection.Clear();
        }

        /// <summary>
        /// Rebuilds the heap.
        /// </summary>
        public void RebuildHeap()
        {
            buildMaxHeap();
        }

        /// <summary>
        /// Returns an array version of this heap.
        /// </summary>
        public T[] ToArray()
        {
            return collection.ToArray();
        }

        /// <summary>
        /// Returns a list version of this heap.
        /// </summary>
        public List<T> ToList()
        {
            return collection.ToList();
        }

        /// <summary>
        /// Union two heaps together, returns a new min-heap of both heaps' elements, 
        /// ... and then destroys the original ones.
        /// </summary>
        public Heap<T> Union(ref Heap<T> firstMaxHeap, ref Heap<T> secondMaxHeap)
        {
            if (firstMaxHeap == null || secondMaxHeap == null)
                throw new ArgumentNullException("Null heaps are not allowed.");

            // Create a new heap with reserved size.
            int size = firstMaxHeap.Count + secondMaxHeap.Count;
            var newHeap = new Heap<T>(size, Comparer<T>.Default);

            // Insert into the new heap.
            while (firstMaxHeap.IsEmpty == false)
                newHeap.Add(firstMaxHeap.Extract());

            while (secondMaxHeap.IsEmpty == false)
                newHeap.Add(secondMaxHeap.Extract());

            // Destroy the two heaps.
            firstMaxHeap = secondMaxHeap = null;

            return newHeap;
        }

        /// <summary>
        /// Swap
        /// </summary>
        /// <param name="collection"></param>
        /// <param name="i"></param>
        /// <param name="j"></param>
        private void Swap(List<T> list, int i, int j)
        {
            T temp = list[i];
            list[i] = list[j];
            list[j] = temp;
        }
    }
